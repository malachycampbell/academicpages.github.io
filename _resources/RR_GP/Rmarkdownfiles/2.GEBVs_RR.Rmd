---
title: "Predicting GEBVs with random regression models"
author: "Malachy Campbell"
date: "8/7/2018"
output:
  rmdformats::html_clean:
    fig_width: 6
    fig_height: 6
    highlight: kate
    thumbnails: true
    lightbox: true
    gallery: true
---

```{r setup, include=FALSE, echo = F}
knitr::opts_knit$set(root.dir = '~/Desktop/RRgwas_git/RR_GP/')
```

# Background
The purpose of this script is to predict genomic breeding values (GEBVs) using a random regression model. The RR model is 
$$ PSA_{tjk} = \mu + \sum_{k=0}^{2}\phi(t)_{jk}\beta_k + \sum_{k=0}^{2}\phi(t)_{jk} u_{jk} + \sum_{k=0}^{1}\phi(t)_{jk} s_{jk} + e_{tjk}$$. Where $\beta$ is the fixed second-order Legendre polynomial to model the overall trend in the trait overtime, $u_{jk}$ and $s_{jk}$ are the $k^{th}$ random regression coefficients for additive genetic effect and random experiment of line $j$, and $e_{tjk}$ is the random residual. This model was seelcted through comparisons between several other RR models. The complete process is decribed in our previous paper in Plant Direct and on [bioRxiv](https://www.biorxiv.org/content/early/2018/07/12/319897).

Since asreml-R does not allow the use of Legendre polynomials all analysis were done with the standalone version of ASREML. Below the ".as" file is provided as well as the call from the commandline.

# Fitting the RR model.
Here is the .as file.
```{asreml .as file, execute = F, echo = T}
RR model selection
 NID !A
 Exp !A
 Rep 2
 DayOfImaging 20 !I
 PSA !/100000
G2.grm
PSA.cleaned.csv !SKIP 1 !MAXITER 1000 !EXTRA 100 !WORKSPACE 6144 !ASUV !DOPATH 8

!PATH 1 #Model1
!ASSIGN USg !< !INIT
0.254496
!>
PSA ~ mu leg(DayOfImaging,2) !r leg(DayOfImaging,0).Exp leg(DayOfImaging,0).grm(NID) !f mv

!PATH 2 #Model2: 19358.83 -38673.65 -38495.60
!ASSIGN USe !< !INIT
1.60E-03 1.52E-03 2.06E-03 3.00E-03 4.59E-03 7.12E-03 1.13E-02 1.82E-02 2.86E-02 4.11E-02 6.09E-02 9.26E-02 1.33E-01 1.87E-01 2.69E-01 0.349805 0.503757 0.740224 1.06494 1.52276
!>
!ASSIGN USg !< !INIT
0.254496
!>
PSA ~ mu leg(DayOfImaging,2) !r leg(DayOfImaging,0).Exp us(leg(DayOfImaging,0) $USg).grm(NID) !f mv
residual id(2142).idh(DayOfImaging $USe)

!PATH 3 #Model3: 
!ASSIGN USg !< !INIT
0.254496
0.200363 0.159373
!>
PSA ~ mu leg(DayOfImaging,2) !r leg(DayOfImaging,0).Exp us(leg(DayOfImaging,1) $USg).grm(NID) !f mv

!PATH 4 #Model4: 23273.62 -46499.24 -46305.01
!ASSIGN USe !< !INIT
1.60E-03 1.52E-03 2.06E-03 3.00E-03 4.59E-03 7.12E-03 1.13E-02 1.82E-02 2.86E-02 4.11E-02 6.09E-02 9.26E-02 1.33E-01 1.87E-01 2.69E-01 0.349805 0.503757 0.740224 1.06494 1.52276
!>
!ASSIGN USg !< !INIT
0.254496
0.200363 0.159373
!>
PSA ~ mu leg(DayOfImaging,2) !r leg(DayOfImaging,0).Exp us(leg(DayOfImaging,1) $USg).grm(NID) !f mv
residual id(2142).idh(DayOfImaging $USe)

!PATH 5 #Model5: 
!ASSIGN USg !< !INIT
0.667162
0.587027 0.519362
0.185506 0.164992 0.526885E-01
!>
PSA ~ mu leg(DayOfImaging,2) !r leg(DayOfImaging,0).Exp us(leg(DayOfImaging,2) $USg).grm(NID) !f mv

!PATH 6 #Model6: 24718.93 -49383.86 -49165.35
!ASSIGN USe !< !INIT
1.60E-03 1.52E-03 2.06E-03 3.00E-03 4.59E-03 7.12E-03 1.13E-02 1.82E-02 2.86E-02 4.11E-02 6.09E-02 9.26E-02 1.33E-01 1.87E-01 2.69E-01 0.349805 0.503757 0.740224 1.06494 1.52276
!>
!ASSIGN USg !< !INIT
0.254496
0.200363 0.159373
0.514966E-01 0.414476E-01 0.109234E-01
!>
PSA ~ mu leg(DayOfImaging,2) !r leg(DayOfImaging,0).Exp us(leg(DayOfImaging,2) $USg).grm(NID) !f mv
residual id(2142).idh(DayOfImaging $USe)

!PATH 7 #Model7: 
!ASSIGN USg !< !INIT
0.685896
0.589393 0.509177
0.190862 0.166014 0.545985E-01
!>
!ASSIGN USp !< !INIT
0.162107
0.151803 0.147320
!>
PSA ~ mu leg(DayOfImaging,2) !r us(leg(DayOfImaging,1) $USp).Exp us(leg(DayOfImaging,2) $USg).grm(NID) !f mv

!PATH 8 #Model8: 27537.59 -55017.19 -54782.49
!ASSIGN USe !< !INIT
1.37E-03 1.22E-03 2.07E-03 3.32E-03 5.32E-03 7.88E-03 1.18E-02 1.53E-02 2.04E-02 2.76E-02 4.03E-02 5.80E-02 8.19E-02 0.114627 0.164452 0.224128 0.336555 0.522506 0.790597 1.17392
!>
!ASSIGN USg !< !INIT
0.629183
0.495574 0.394557
0.129607 0.104540 0.281278E-01
!>
!ASSIGN USp !< !INIT
0.594161E-01
0.392295E-01 0.260640E-01
!>
PSA ~ mu leg(DayOfImaging,2) !r us(leg(DayOfImaging,1) $USp).Exp us(leg(DayOfImaging,2) $USg).grm(NID) !f mv
residual id(2142).idh(DayOfImaging $USe)
```

Here is how it was run.
```{bash run asreml}
cd /Users/malachycampbell/Desktop/RRgwas_git/RR_GP/

asreml RR.as
```

# Solving for GEBVs at each time point
GEBVs at each time point were be obtained following to [Mrode (2014)](https://books.google.com/books?hl=en&lr=&id=b6MKAwAAQBAJ&oi=fnd&pg=PR5&dq=mrode+linear+models&ots=8Q3ejuZBpU&sig=PVGj2Zi13XD9f_ATZt3Pt4X7r1U). For line $j$ at time $t$, the GEBVs can be obtained by $\text{gBLUP}_{jt} = \phi_t\hat{u}_j$; where $\phi_t$ is the row vector of the matrix of Legendre polynomials of order 2. 

The functions below were adapted from Mrode (2005) by [Gota Morota](http://morotalab.org/Mrode2005/rr/rr.html#section00020000000000000000)
```{r load functions for RR with leg polynomials, echo=FALSE}
##Return coefficient matrix (lambda) of n-th order Legendre polynomials. Scaling method implemented by Gengler et. al. (1999) converts constant Legendre polynomial coefficients into 1
`legendre` <-
  function(n, gengler){
    
    if (nargs()==1){
      gengler <- TRUE	
    }
    
    if (gengler != TRUE & gengler != FALSE){
      gengler=TRUE	
    }
    
    N <- n+1
    L <- matrix(0,nrow=N, ncol=N)
    
    for(i in (1:N)){
      if(i==1){
        L[i,i] <- 1
      }
      else if(i==2){
        L[i,i] <- 1
      }
      else  {
        tmp <- L[i-1,]
        tmp2 <- as.numeric()
        tmp2 <- c(0,tmp[1:(N-1)])
        L[i,] <- (1/(i-2+1))*( (2*(i-2) + 1)*tmp2 -(i-2)*L[i-2,] )
      }
    }
    
    # Normalize
    for (j in (1:N)){	
      L[j,] <- (sqrt( (2*(j-1)+1)/2)  )*L[j,]
    }
    
    
    # Gengler (1999)
    if (gengler==TRUE){
      L <- sqrt(2)*L
    }
    
    return(L)
    
  }

##Given time points covariate and order of fit for Legendre polynomials, return matrix 'M' containing the polynomials of standardized time. 'M' is order t (number of time points) by k (order of Legendre polynomials)
stdtime <- function(t, n, tmax, tmin){
  if(missing(tmax)) {
    tmax <- t[which.max(t)]
  }
  if(missing(tmin)) {
    tmin <- t[which.min(t)]
  }
  
  N <- n+1
  M <- matrix(0, nrow=length(t), ncol=N)
  a <- -1 + 2*(t-tmin)/(tmax - tmin)
  M[,1] <- 1
  
  for (i in 2:N){
    M[,i] <- a^(i-1)
  }
  
  return(M)
}
```

Here, we'll take the sln files, extract the breeding values for the RR coefficients, and calcualte the gBLUPs at each time point.
```{r solve for BVs at each time point}
library(reshape2)

setwd("/Users/malachycampbell/Desktop/RRgwas_git/RR_GP/")

sln <- read.delim("RR.sln", sep="", header=T)
  
#gBLUPs for legendre polynomials
g.hat.y <- t(cbind(sln[grep("1.NSFTV", sln$Level) ,][,3],
                     sln[grep("2.NSFTV", sln$Level) ,][,3],
                     sln[grep("3.NSFTV", sln$Level) ,][,3]))
  
colnames(g.hat.y) <- sub("1.", "", sln[grep("1.NSFTV", sln$Level) ,][,2])
  
#Calculated gBLUPs at each time point
Phi <- stdtime(1:20, 2) %*% t(legendre(2, gengler = F))
ghat.t.y <- t(apply(g.hat.y, 2, function (x) Phi %*% x))
colnames(ghat.t.y) <- 1:20
gBLUP <- melt(ghat.t.y)
colnames(gBLUP) <- c("NSFTV.ID", "DayOfImaging", "gBLUP")

write.csv(gBLUP, "/Users/malachycampbell/Desktop/RRgwas_git/RR_GP/RR_GEBVs.csv", row.names = F)
```